---
title: "【GCP】CloudSQLとGAEでGoアプリをデプロイしちゃうぞ"
emoji: "🐁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go", "GCP"]
published: false
---

# はじめに

Go で簡単なアプリを作って GoogleAppEngine(以下「GAE」）のフレキシブル環境でデプロイしてみたので、ハンズオン風自分用のメモとして残します。
GAE はスタンダード環境だと超簡単にデプロイできますが、ランタイムのバージョンが限られているところがネックです。
例えば Go は執筆時点では`1.19`が最新バージョンですが、`1.16`までとまあまあ古いランタイムしか使えません。
ちなみにフレキシブル環境は何故か`1.15`までしか使えませんが、自分で Dockerfile 作ればそれをランタイムとして使えるので、実質制限がありません。

...という前提で記事書いてた途中に`1.19`が使えるようになりました笑
これ以降は`1.16`までしか対応していない時期に執筆しているので、ご承知おきください〜。

https://twitter.com/golang/status/1600868557390479360?s=20&t=v2_vsziqj49vmfTSlzg7KQ

# リポジトリ

参考までに今回作業していたリポジトリは以下です。

https://github.com/chillout2san/chi_authentication

またこの記事執筆時点での最新の commit のハッシュ値は`6b03e7243f5b52ed8ebea4fa646475210bc9066e`です。
今後も commit 積むかも知れないので、進んでたら`git reset --hard`とかで巻き戻してください。

# 前準備

- Google アカウントの作成は省略します。

- 以下ドキュメントを参考に GCP にログインしましょう。執筆時点では有効期限 90 日で 300 ドル分クレジットがもらえます。

https://cloud.google.com/docs/get-started?hl=ja

- コンソールに移動したら、`My First Project`というサンプルのプロジェクトにいるはずです。そのままでも良いですし、新しくプロジェクト作成してもらっても OK です。今回は`LearnGCP`という名前にしました。

# GCP の sdk をインストールする

- 以下ドキュメントを参考に sdk をインストールします。
- 各 OS ごとに用意されているフォルダをダウンロードして、解凍したものを配置したディレクトリでインストールのシェルスクリプトを叩くと、配置したディレクトリで`gcloud`コマンドのパスが通ります。ダウンロードフォルダとかでパス通るとめんどくさいので、ドキュメントにも記載がありますがホームディレクトリにファイルを解凍してからスクリプト叩くと良いでしょう。

https://cloud.google.com/sdk/docs/install?hl=ja

- インストール終わったら、以下コマンドを叩きましょう。バージョン情報が出てきたら OK です。出ない人はターミナルを再起動してみてください。

```bash
$ gcloud version
```

# CloudSQL の準備をする

- データベース使わない人はスキップ可です。

- メニューから CloudSQL を選択。

![image.png](/images/c7b1bd4feb8800/sql.png)

- `インスタンスを生成`を押下。

![image.png](/images/c7b1bd4feb8800/create_sql_instance.png)

- 今回は MySQL を選択しました。

![image.png](/images/c7b1bd4feb8800/select_mysql.png)

- インスタンス ID とパスワードを設定します。インスタンス ID は分かりやすいものであれば何でも OK です。パスワードはこのデータベースに root ユーザーでアクセスするものになるので控えておきましょう。右にある`生成`を押すと安全なパスワードを生成できます。今回 MySQL のバージョンは`8.0`を選択しました。

![image.png](/images/c7b1bd4feb8800/instance_infomation.png)

- 構成の選択を行います。本番環境用のマッチョな構成か、開発環境用のコスパ高い構成かを選べます。今回は開発用なので`development`を選択しました。画面にも説明がありますが、構成の選択と言ってもオススメの設定をとりあえず GCP が設定してくれるだけで、後ほど各項目をカスタマイズできます。なのであんまり深く考えるところではないですね。

![image.png](/images/c7b1bd4feb8800/start_composition.png)

- リージョンとゾーンを選択します。今回は東京にしました。開発用なので高可用性にするかどうかはノーで大丈夫です。めっちゃ簡単に言うと、A インスタンスが使えなくなったら自動で B インスタンスに代わってシステムを維持するよということです。詳しく知りたい方は以下ドキュメントを参考にしてください。

![image.png](/images/c7b1bd4feb8800/region_and_zone.png)

https://cloud.google.com/solutions/cloud-sql-mysql-disaster-recovery-complete-failover-fallback?hl=ja

- マシンタイプを選択します。`共有コア`が一番安くなりますが、何となく`軽量`を選択しました。

![image.png](/images/c7b1bd4feb8800/machine_type.png)

- ストレージの設定を行います。`SSD`、`10GB`、写真はオンになっちゃってますが自動増量はオフにしました。趣味レベルでちょろっと使うだけなら、`HDD`でも良いかも知れません。`暗号化`のところはあんまり分かってません・・・。

![image.png](/images/c7b1bd4feb8800/storage.png)

- 接続の設定を行います。同じ GCP のサービスである GAE からは特段の設定なしにアクセスできました。おそらくデフォルトで認可済みネットワークに入っているっぽいですね。

![image.png](/images/c7b1bd4feb8800/connection.png)

- データの保護の箇所です。実験用なので全てオフにします。

![image.png](/images/c7b1bd4feb8800/data_defence.png)

- メンテナンスの設定です。例えば営業ツールのような日中によく使われるシステムだからメンテナンスは夜に実行されるように、みたいな調整ができます。今回はこだわりがないので`おまかせ`にしてます。

![image.png](/images/c7b1bd4feb8800/maintenance.png)

- フラグとラベルは設定不要です。インスタンスを生成をクリックしてください。5 分程度時間かかりますが、インスタンス生成完了まで待ちましょう。完了したらインスタンス名をクリックします。

![image.png](/images/c7b1bd4feb8800/instance_list.png)

- 接続名も後ほど使いますので控えておいてください。ここでデータベースを作成だけしたいので、`CLOUD SHELLで開く`を押下してインスタンスの中に入ります。

![image.png](/images/c7b1bd4feb8800/instance_info.png)

- コマンドが入力された状態で立ち上がるのでエンターで実行します。

![image.png](/images/c7b1bd4feb8800/cloud_shell.png)

- 先ほど控えておいたパスワードを入力します。写真省略しますが、SQL が打てるようになるので、データベース作成するなり、テーブル作成するなりやってください。今回はテーブル作成するスクリプトをサボって書いていないので SQL 直叩きしました。

![image.png](/images/c7b1bd4feb8800/cloud_shell_s.png)

https://github.com/chillout2san/chi_authentication/blob/main/migration/schema/create_table.sql

# ローカルでCloudSQLへの接続のテストをする

- ここまで準備出来たら一度ローカルで実行してみましょう。前述のリポジトリで作業いただいている方は以下コマンド実行してください。

```
$ DB_USER=root DB_PASS={控えたパスワード} DB_NAME={ご自身で入力したもの} INSTANCE_CONNECTION_NAME={控えた接続名} JWT_SECRET_KEY=secret go run cmd/main.go
```

- すると以下のようなメッセージが出て怒られます。

```
2022/12/10 23:47:10 CloudSQLConn NewDaialer failed: failed to create token source: google: could not find default credentials. See https://developers.google.com/accounts/docs/application-default-credentials for more information.
```

- このURLを見ろと言われたので見てみましょう。するとローカルからCloudSQLに接続するための認証情報を加える必要があることが分かります。

https://developers.google.com/accounts/docs/application-default-credentials

- ベストプラクティスではないようですが、簡単に認証情報のjsonをダウンロードして環境変数に渡すやり方を取ります。`IAMと管理`から`サービスアカウントを作成`を押下します。

![image.png](/images/c7b1bd4feb8800/create_service_account.png)

- サービスアカウントのIDを入力します。適当に入力します。

![image.png](/images/c7b1bd4feb8800/service_first.png)

- ロールを`編集者`にします。もっと細かく設定が出来ますが、今回は実験用なのでざっくり行きます。

![image.png](/images/c7b1bd4feb8800/service_second.png)

- こちらはスルーでOKです。サービスアカウントのアクセスをユーザーに渡すかどうかです。実験用なので使いません。今回はオーナー権限持っているアカウント(GCPにログインしているGoogleアカウントが自動でオーナー権限に割り当たっている)使ってしまいます。

![image.png](/images/c7b1bd4feb8800/service_third.png)

- サービスアカウントが作成できたら、`鍵を追加`を押下してキータイプはjsonで秘密鍵を生成します。ダウンロードされるので、`/home/ssh`とかに保存してください。

- 先ほど実行したコマンドに`GOOGLE_APPLICATION_CREDENTIALS`という環境変数を一つ足します。値は秘密鍵のパスです。これで実行すればエラーが出てこないはずです。

```
$ GOOGLE_APPLICATION_CREDENTIALS={秘密鍵のパス} DB_USER=root DB_PASS={控えたパスワード} DB_NAME={ご自身で入力したもの} INSTANCE_CONNECTION_NAME={控えた接続名} JWT_SECRET_KEY=secret go run cmd/main.go
```

- 動作確認として以下のようにリクエスト投げてみてください。今回はPostmanを使ってリクエスト投げました。

![image.png](/images/c7b1bd4feb8800/localtest.png)

# Dockerfile を準備する

- デプロイする用の超シンプルな Dockerfile を用意します。コンテナへの接続うんぬんは GAE がやってくれるようです。楽ですね。

```Dockerfile
FROM golang:1.19-alpine

WORKDIR /app

COPY . .

RUN go mod tidy

RUN go build ./cmd/main.go

CMD ["./main"]
```

# CloudSQL と Go アプリケーションを接続する

- 以下記事を参考に、CloudSQL と Go のアプリケーションを接続します。TCP ソケット経由、Unix ソケット経由、CloudSQL コネクタの 3 パターン方法があり、今回は CloudSQL コネクターで接続しました。

https://cloud.google.com/sql/docs/mysql/connect-app-engine-flexible?hl=ja#connect_to

```go:database.go
var Db *sql.DB

func init() {
    // 今更タイポ見つけたけど、見なかったことにする。
    e := config.Enviroment

    d, err := cloudsqlconn.NewDialer(context.Background())
    if err != nil {
        log.Println("CloudSQLConn NewDaialer failed:", err)
    }
    mysql.RegisterDialContext("cloudsqlconn",
        func(ctx context.Context, addr string) (net.Conn, error) {
            // DbHostはCloudSQL作成時の「接続名」のところ。
            // {project名}:{リージョン}:{インスタンスのid}の形になっているはず。
            return d.Dial(ctx, e.DbHost)
        })

    dsn := fmt.Sprintf("%s:%s@cloudsqlconn(localhost:3306)/%s?parseTime=true",
        // DbUserはroot、DbPassは設定したパスワード。
        // DbNameはCloudShellでMySQLインスタンスの中に入ってデータベースを作成する。
        e.DbUser, e.DbPass, e.DbName)

    db, err := sql.Open("mysql", dsn)

    if err != nil {
        log.Println("Database connection failed:", err)
        return
    }

    Db = db
    // 実は接続自体が成功しているわけではないのだが、まあヨシとする。
    log.Println("Database connection success")
}
```

https://github.com/chillout2san/chi_authentication/blob/main/infrastructure/database.go

# app.yaml を準備する

- さてここからはいよいよ GAE へのデプロイの準備です。ドキュメントをガン見しながら進めていきます。GCP はドキュメントが本当に見やすくて助かります。

https://cloud.google.com/appengine/docs?hl=ja

- app.yaml は GAE のデプロイ用の設定ファイルのようなものです。ちなみに必ず app.yaml という名前にする必要はないので、production.yaml とか development.yaml みたいな名前もアリです。必要最低限の構成を考えてみます。

```yaml:app.yaml
# 自前のDockerfileを使用する
runtime: custom
# フレキシブル環境を使う
env: flex
# GAEにデプロイした後のサービス名。何でも良いです。今回はリポジトリの名前そのまんまです。
# 指定しないとdefaultという名前そのまんまのデフォルトのサービスにデプロイされます。
service: chi-authentication

# 環境変数を使う場合はここに書く。
env_variables:
  ALLOW_ORIGIN:
  DB_USER:
  DB_PASS:
  DB_NAME:
  INSTANCE_CONNECTION_NAME:
  JWT_SECRET_KEY:
```

- フレキシブル環境はスタンダード環境と違ってゼロインスタンス運用が出来ません。そのためスケールの設定にはより気を配る必要があります。

https://cloud.google.com/appengine/docs/the-appengine-environments?hl=ja

- app.yaml でスケールの設定を細かく決めることが出来ます。詳細はリファレンスは公式を参照してください。重要そうな項目を抜粋してみます。

https://cloud.google.com/appengine/docs/flexible/reference/app-yaml?hl=ja&tab=go

- GAE のフレキシブル環境はデフォルトでは自動スケーリング、つまり勝手にスケールしていきます。その設定を詳しくできます。

```yaml:app.yaml
automatic_scaling:
  # 最小のインスタンス数。ゼロインスタンス運用できないので1以上。デフォルトは2。
  # 趣味の開発用であれば1にしてコストカットできそう。
  min_num_instances: 1
  # 最大のインスタンス数。デフォルトは20。
  # 趣味レベルならどうでも良さそうだけど、怖いので数字は絞っておきたい。
  max_num_instances: 15
  # 新しいインスタンスが立ち上がってから利用されるまでの時間っぽい。
  # 起動中のインスタンスにリクエストが行って変な待ち時間を作らないように、ということかも。
  # Javaとか起動に時間がかかるやつの場合は長めに取ると良いのかも。
  # 60秒以上にする必要があり、デフォルトは120秒。あんまり課金には関係なさそう。
  cool_down_period_sec: 180
  cpu_utilization:
    # これもよく分からなかった。
    # 多分インスタンス増減を決めるCPU使用率の閾値っぽい。
    target_utilization: 0.6
  # まだベータ版だったので一旦無視。
  target_concurrent_requests: 100
```

- 趣味開発レベルで課金が怖い場合は手動スケーリングにしておくという手もあります。

```yaml:app.yaml
manual_scaling:
  # ドキュメントには書いてなかったけど、1以上であれば設定できそう。
  instances: 5
```

# デプロイしてみましょう

確認するべきはアカウントとプロジェクト
スクリプトにまとめてあるけど、大事なのは gcloud app deploy ですよ。

# 動作確認

# おわりに

- 普段業務ではインフラ周りを触らないので楽しかった。趣味レベルで AWS も触ったことあるけど、GCP の方がドキュメント読みやすくていいなと思った。

- GAE は環境変数を app.yaml 内に持たせるので、ローカルでアプリケーション実行する際には別途 env ファイルを用意しないと行けなさそう。それか app.yaml には持たせずに env ファイルに全部書いちゃって、Dockerfile でその env ファイル読み込めば行けるのかしら？

- それにしても app.yaml に設定する項目は必要最低限かつ十分という感じ。ユーザーがインフラの管理を意識せず、アプリ開発に集中できる素晴らしいサービスですね。

- 本記事執筆前に GAE フレキシブルかつ Docker 使った記事を探したが案外なかった。何でだろうと考えてたけど、それなら CloudRun 使うわっていう話なのかも？次は CloudRun 試してみたい。それ終わったら Terraform で IaC やってみたいなあ。
